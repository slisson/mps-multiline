package de.slisson.mps.editor.multiline.cells;

/*Generated by MPS */

import jetbrains.mps.nodeEditor.selection.AbstractSelection;
import jetbrains.mps.logging.Logger;
import jetbrains.mps.nodeEditor.EditorComponent;
import java.util.Map;
import jetbrains.mps.nodeEditor.cells.CellInfo;
import jetbrains.mps.nodeEditor.selection.SelectionStoreException;
import jetbrains.mps.nodeEditor.selection.SelectionRestoreException;
import jetbrains.mps.nodeEditor.cells.EditorCell;
import jetbrains.mps.nodeEditor.selection.SelectionInfo;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.awt.Rectangle;
import jetbrains.mps.nodeEditor.CellActionType;
import de.slisson.mps.editor.multiline.runtime.ClipboardUtils;
import jetbrains.mps.nodeEditor.cells.CellConditions;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.nodeEditor.selection.SelectionManager;
import jetbrains.mps.nodeEditor.selection.Selection;
import jetbrains.mps.nodeEditor.selection.SingularSelection;
import jetbrains.mps.nodeEditor.selection.EditorCellLabelSelection;
import java.util.List;
import java.util.Collections;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.project.structure.modules.ModuleReference;
import java.awt.Graphics2D;
import jetbrains.mps.nodeEditor.cells.ParentSettings;
import java.util.Stack;

public class MultilineSelection extends AbstractSelection {
  private static final Logger LOG = Logger.getLogger(MultilineSelection.class);
  private static final String PROPERTY_SELECTION_START = "selectionStart";
  private static final String PROPERTY_SELECTION_END = "selectionEnd";

  private EditorCell_Multiline myMultilineCell;
  private int mySelectionStart;
  /**
   * can be lower than mySelectionStart
   */
  private int mySelectionEnd;

  public MultilineSelection(EditorComponent editorComponent, Map<String, String> properties, CellInfo cellInfo) throws SelectionStoreException, SelectionRestoreException {
    super(editorComponent);
    if (cellInfo == null) {
      throw new SelectionStoreException("Required CellInfo parameter is null");
    }
    EditorCell editorCell = cellInfo.findCell(editorComponent);
    if (editorCell instanceof EditorCell_Multiline) {
      myMultilineCell = (EditorCell_Multiline) editorCell;
    } else {
      throw new SelectionRestoreException();
    }
    int start = SelectionInfo.Util.getIntProperty(properties, PROPERTY_SELECTION_START);
    int end = SelectionInfo.Util.getIntProperty(properties, PROPERTY_SELECTION_END);
    setSelectionRange(start, end);
  }

  public MultilineSelection(@NotNull EditorComponent editorComponent, @NotNull EditorCell_Multiline multilineCell, int start, int end) {
    super(editorComponent);
    myMultilineCell = multilineCell;
    setSelectionRange(start, end);
  }

  public void setSelectionStart(int newValue) {
    setSelectionRange(newValue, mySelectionEnd);
  }

  public void setSelectionEnd(int newValue) {
    setSelectionRange(mySelectionStart, newValue);
  }

  public void setSelectionRange(int selStart, int selEnd) {
    mySelectionStart = selStart;
    mySelectionEnd = selEnd;
    updateVisibleSelection(selStart, selEnd);
  }

  public void updateVisibleSelection(int selStart, int selEnd) {
    if (selStart > selEnd) {
      int temp = selStart;
      selStart = selEnd;
      selEnd = temp;
    }
    int wordStart = 0;
    int caretPos = selEnd;
    for (EditorCell_Word wordCell : Sequence.fromIterable(myMultilineCell.getWordCells())) {
      int wordLength = wordCell.getText().length();
      int wordEnd = wordStart + wordLength;
      if (wordStart <= caretPos && caretPos <= wordEnd && selEnd != selStart) {
        wordCell.setCaretPosition(caretPos - wordStart);
      }
      wordCell.setSelectionStart(limitValue(selStart - wordStart, 0, wordLength));
      wordCell.setSelectionEnd(limitValue(selEnd - wordStart, 0, wordLength));
      wordStart += wordCell.getTextIncludingSeparator().length();
    }
  }

  public void activate() {
    updateVisibleSelection(mySelectionStart, mySelectionEnd);
    updateCursorPosition();
    Rectangle firstBound = myMultilineCell.getWordCellContainingPos(mySelectionStart).getBounds();
    Rectangle lastBounds = myMultilineCell.getWordCellContainingPos(mySelectionEnd).getBounds();
    getEditorComponent().scrollRectToVisible(firstBound.union(lastBounds));
    getEditorComponent().repaint();
  }

  public void deactivate() {
    updateVisibleSelection(0, 0);
  }

  public void ensureVisible() {
    EditorCell_Word firstSelectedWordCell = myMultilineCell.getWordCellContainingPos(mySelectionStart);
    if (firstSelectedWordCell != null) {
      firstSelectedWordCell.getEditor().scrollToCell(firstSelectedWordCell);
    }
  }

  public void executeAction(CellActionType type) {
    if (CellActionType.SELECT_LEFT == type || CellActionType.SELECT_RIGHT == type) {
      int newEnd = (type == CellActionType.SELECT_LEFT ?
        mySelectionEnd - 1 :
        mySelectionEnd + 1
      );
      changeSelection(newEnd);
    } else if (type == CellActionType.DELETE || type == CellActionType.BACKSPACE) {
      executeDeleteSelectedText();
    } else if (type == CellActionType.COPY) {
      ClipboardUtils.setClipboardText(getSelectedText());
    } else if (type == CellActionType.CUT) {
      executeAction(CellActionType.COPY);
      executeDeleteSelectedText();
    } else if (type == CellActionType.PASTE) {
      pasteClipboardText();
    } else if (type == CellActionType.SELECT_PREVIOUS || type == CellActionType.SELECT_UP) {
      selectUpOrDown(true);
    } else if (type == CellActionType.SELECT_NEXT || type == CellActionType.SELECT_DOWN) {
      selectUpOrDown(false);
    } else if (type == CellActionType.LEFT || type == CellActionType.RIGHT || type == CellActionType.DOWN || type == CellActionType.UP) {
      clearSelection();
    } else {
      LOG.info("unhandled action: " + type);
    }
  }

  public String getSelectedText() {
    int first = Math.min(mySelectionStart, mySelectionEnd);
    int last = Math.max(mySelectionStart, mySelectionEnd);
    return myMultilineCell.getText().substring(first, last);
  }

  public void clearSelection() {
    int caretPos = mySelectionEnd;
    setSelectionRange(caretPos, caretPos);
    myMultilineCell.setCaretPosition(caretPos, true);
  }

  public void pasteClipboardText() {
    getEditorComponent().getEditorContext().executeCommand(new Runnable() {
      public void run() {
        deleteSelectedText();
        String textToInsert = ClipboardUtils.getClipboardText();
        myMultilineCell.insertText(textToInsert);
      }
    });
  }

  public void selectUpOrDown(boolean up) {
    EditorCell_Word cursorCell = myMultilineCell.getWordCellContainingPos(mySelectionEnd);
    EditorCell upperOrLower = (up ?
      cursorCell.getUpper(CellConditions.SELECTABLE, cursorCell.getCaretX()) :
      cursorCell.getLower(CellConditions.SELECTABLE, cursorCell.getCaretX())
    );
    if (!(upperOrLower instanceof EditorCell_Word)) {
      return;
    }
    EditorCell_Word upperOrLowerWordCell = (EditorCell_Word) upperOrLower;
    if (upperOrLowerWordCell.getParent() != myMultilineCell) {
      return;
    }

    upperOrLowerWordCell.setCaretX(cursorCell.getCaretX());
    int newEnd = myMultilineCell.getTextBefore(upperOrLowerWordCell, upperOrLowerWordCell.getCaretPosition()).length();
    changeSelection(newEnd);
  }

  public void executeDeleteSelectedText() {
    if (ModelAccess.instance().canWrite()) {
      deleteSelectedText();
    } else {
      getEditorComponent().getEditorContext().executeCommand(new Runnable() {
        public void run() {
          deleteSelectedText();
        }
      });
    }
  }

  public void deleteSelectedText() {
    int first = Math.min(mySelectionStart, mySelectionEnd);
    int last = Math.max(mySelectionStart, mySelectionEnd);
    String text = myMultilineCell.getText();
    text = text.substring(0, first) + text.substring(last, text.length());
    myMultilineCell.setText(text);
    setSelectionRange(0, 0);
    myMultilineCell.setCaretPosition(first, true);
  }

  private void changeSelection(int newEnd) {
    SelectionManager selectionManager = getEditorComponent().getSelectionManager();
    Selection newSelection;
    if (newEnd != mySelectionEnd) {
      newSelection = new MultilineSelection(getEditorComponent(), myMultilineCell, mySelectionStart, newEnd);
    } else {
      newSelection = selectionManager.createSelection(myMultilineCell.getParent());
      if (newSelection instanceof SingularSelection) {
        ((SingularSelection) newSelection).setSideSelectDirection((mySelectionStart > newEnd ?
          SingularSelection.SideSelectDirection.LEFT :
          SingularSelection.SideSelectDirection.RIGHT
        ));
      }
    }
    selectionManager.pushSelection(newSelection);
  }

  public void updateCursorPosition() {
    EditorCell_Word cursorCell = myMultilineCell.getWordCellContainingPos(mySelectionEnd);
    if (cursorCell != null) {
      myMultilineCell.setCaretPosition(mySelectionEnd);
      SelectionManager selectionManager = getEditorComponent().getSelectionManager();
      setDeepestSelection(new EditorCellLabelSelection(cursorCell), selectionManager);
    }
  }

  private void reduceSelection() {
    SelectionManager selectionManager = getEditorComponent().getSelectionManager();
    selectionManager.popSelection();
  }

  @NotNull
  public List<EditorCell> getSelectedCells() {
    return Collections.singletonList((EditorCell) myMultilineCell);
  }

  @NotNull
  public List<SNode> getSelectedNodes() {
    return Collections.singletonList(myMultilineCell.getSNode());
  }

  public SelectionInfo getSelectionInfo() throws SelectionStoreException {
    SelectionInfo selectionInfo = new SelectionInfo(this.getClass().getName(), ModuleReference.fromString("dc038ceb-b7ea-4fea-ac12-55f7400e97ba(de.slisson.mps.editor.multiline.runtime)").getModuleFqName());
    selectionInfo.setCellInfo(myMultilineCell.getCellInfo());
    selectionInfo.getPropertiesMap().put(PROPERTY_SELECTION_START, Integer.toString(mySelectionStart));
    selectionInfo.getPropertiesMap().put(PROPERTY_SELECTION_END, Integer.toString(mySelectionEnd));
    return selectionInfo;
  }

  public boolean isSame(Selection other) {
    if (this == other) {
      return true;
    }
    if (other == null || getClass() != other.getClass()) {
      return false;
    }
    MultilineSelection otherSelection = (MultilineSelection) other;
    if (!(myMultilineCell.equals(otherSelection.myMultilineCell))) {
      return false;
    }
    if (mySelectionStart != otherSelection.mySelectionStart) {
      return false;
    }
    if (mySelectionEnd != otherSelection.mySelectionEnd) {
      return false;
    }
    return true;
  }

  public void paintSelection(Graphics2D g) {
    /*
      for (EditorCell_Word wordCell : myMultilineCell.getWordCells()) {
        if (!(g.hitClip(wordCell.getX(), wordCell.getY(), wordCell.getWidth(), wordCell.getHeight()))) {
          continue;
        }
        wordCell.paint(g, ParentSettings.createDefaultSetting());
      }
    */
  }

  public int getCaretPosition() {
    return mySelectionEnd;
  }

  public EditorCell_Word getCellContainingCaret() {
    return myMultilineCell.getWordCellContainingPos(getCaretPosition());
  }

  public static int limitValue(int value, int min, int max) {
    int result = value;
    result = Math.min(result, max);
    result = Math.max(result, min);
    return result;
  }

  public static void setDeepestSelection(Selection newDeepest, SelectionManager manager) {
    try {
      Stack<SelectionInfo> selectionInfoStack = manager.getSelectionInfoStack();
      selectionInfoStack.set(0, newDeepest.getSelectionInfo());
      manager.setSelectionInfoStack(selectionInfoStack);
    } catch (SelectionStoreException ex) {
      LOG.error(ex);
    }
  }
}
